#!/usr/bin/perl

# Implementation progress:
# create "Daten" interface -> OK
# adapt namespace for StatusStm.cpp and move/copy
    # correct namespaces -> OK
    # check includes -> OK
    #generate ActionHandle with c-function that call IActions -> OK
    # toString for states/events -> OK
    # adapt checkParameter -> OK
# adapt StatusStm.hpp:
    # parse for actions: -> OK
        #generate IActions -> OK
    # correct namespaces -> OK
    # check includes -> OK
    # toString for states/events -> OK
# generate some facade for the statemachine -> OK
    # with event queue when needed

use strict;
use warnings;

use File::Basename;
use File::Spec;

sub parseAuthorMail {
  my $author = 'dresden.tsd.automotive.phone@technisat.de';
  my $filename = $ENV{"HOME"}."/.gitconfig";
  if ((-r $filename) and (open(FILE, $filename))) {
    my $line;
    while (not eof(FILE))
    {
      $line = <FILE>;
      if ($line =~ /email\s*=\s*((\w|\.|_)+\@(\w|\.|_)+)/) {
        $author = $1;
      }
    }
    close(FILE);
  }
  return $author;
}

our $SCRIPTNAME     = basename($0);
our $AUTHORMAIL     = parseAuthorMail();  # 'marcus.waschke@preh.de';
our $INDENT         = ' ' x 3; # current PCC code style
our $OVERWRITE_FILE = 0;
our $VERSION = 6;

our $HELPMESSAGE = <<END;
Refurbish C++ source code of a statemachine that was generated with stmgen. Version $VERSION
Synopsis:
\\> $SCRIPTNAME <Namespace> <Path2Stm> <NameStm>
Namespace Full qualified C++ namespace that is used for this static_cast.
Path2Stm  Path to the statemachine in the EA export file.
NameStm   The name of the statemachine.

E.g. "\\> $SCRIPTNAME tsd::foo stm BarStm" will generate:
tsd::foo::BarStm
tsd::foo::IData
tsd::foo::IActionHandler

Note that the following author will be set in the file header:
$AUTHORMAIL
END

# @namespaces Array with strings.
sub createOpeningNamespaceString {
  my (@namespaces) = @_;

  my $result = "";
  my $count = 0;
  foreach my $s (@namespaces) {
    if ($count lt $#namespaces) {
      $result .= "namespace $s {\n";
    }
    $count++;
  }
  return $result;
}

# @namespaces Array with strings.
sub createClosingNamespaceString {
  my (@namespaces) = @_;

  my $result = "";
  my $count = 0;
  foreach my $s (@namespaces) {
    if ($count lt $#namespaces) {
      $result = "} // namespace $s\n".$result;
    }
    $count++;
  }
  return $result;
}

# Concatenate strings to a single string with a separator. The separator is only between the strings.
# $separator String that is insert between the strings from @namespaces.
# $uppercase Flag (0/1) that determines if the strings from @namespaces shall be used uppercase.
# @namespaces Array with strings.
sub concatenateStrings {
  my ($separator, $uppercase, @namespaces) = @_;

  my $result = "";
  my $flag = 0;
  foreach my $n (@namespaces) {
    if ($flag gt 0) {
      $result .= $separator;
    }

    if ($uppercase ne 0) {
      $result .= uc $n;
    } else {
      $result .= $n;
    }
    $flag = 1;
  }
  return $result;
}

# Write content to file
# $fileName Name of the file
# $fileContent Content to write
sub writeToFile {
  my ($fileName, $fileContent) = @_;

  print "Try to create file: $fileName\n";

  if ($OVERWRITE_FILE and (-e $fileName)) {
    print STDERR "File $fileName already exists. Do not overwrite -> Exit\n";
    exit(2);
  }

  # write generated content to file
  open(FILE, ">$fileName") || die ("unable to open '$fileName' for write");
  print FILE $fileContent;
  close FILE;
}

# Creates a source code snippet for a function that converts a enumeration value to string.
# $nameStm Name of the statemachine
# $nameEnum Name of the enumeration
# $values Enumeration values
sub generateToString {
  my ($nameStm, $nameEnum, @values) = @_;

  my $strings = "${INDENT}\"UNKNOWN\",\n";
  for my $v (@values) {
    $strings .= "${INDENT}\"$v\",\n";
  }
  my $maxValue = 2 + $#values;

  my $result = <<END;

const char* ${nameEnum}Strings[] = {
$strings};

const char* ${nameStm}::${nameEnum}::toString(const uint16_t value)
{
   return (value < $maxValue) ? ${nameEnum}Strings[value] : ${nameEnum}Strings[0];
}
END
  return $result;
}

# Generate an custom interface.
sub generateInterface {
  my ($fileName, $includeGuard, $includes, $namespaceOpen, $namespaceClose, $interfaceName, $methods, $description, $inheritance) = @_;

  my $fileContent = <<END;
//////////////////////////////////////////////////////////////////////
/// \@file $fileName
///
/// \@author $AUTHORMAIL
///
/// Generated by $SCRIPTNAME version $VERSION
/// Copyright (c) Preh Car Connect GmbH
/// CONFIDENTIAL
//////////////////////////////////////////////////////////////////////

#ifndef $includeGuard\_HPP
#define $includeGuard\_HPP

$includes

$namespaceOpen
$description
class $interfaceName
${inheritance}{
protected:
$INDENT$interfaceName() = default; ///< Default constructor
${INDENT}virtual ~$interfaceName() = default; ///< Default destructor
public:
$INDENT$interfaceName(const $interfaceName&) = delete; ///< Forbidden copy constructor
$INDENT$interfaceName& operator=(const $interfaceName&) = delete; ///< Forbidden assignment operator

public:
$methods
};

$namespaceClose
#endif // $includeGuard\_HPP
END

  writeToFile($fileName, $fileContent);
}

# Generates a pure virtual data pool file in the current working directory
# $filenameInput Path (relative/absolute to the Daten class file
# $namespace Full qualified C++ namespace including the name of IData (e.g. 'tsd::bli::bla::stm::IData')
# $actionsInterface Name of the action handler interface
sub generateVirtualDatapool {
  my ($filenameInput, $namespace, $actionsInterface) = @_;

  my @namespaces = split('::', $namespace);

  my @nsActions;
  { # namespace for actions include
    my $count = 0;
    foreach my $s (@namespaces) {
      if ($count lt $#namespaces) {
        push @nsActions, $s;
      }
      $count++;
    }
    push @nsActions, $actionsInterface;
  }

  my $interfaceName = $namespaces[$#namespaces];
  my $fileName = "$interfaceName.hpp";
  my $namespaceOpen = createOpeningNamespaceString(@namespaces);
  my $namespaceClose = createClosingNamespaceString(@namespaces);
  my $actionsInclude = concatenateStrings("/", 0, @nsActions);
  my $includeGuard = concatenateStrings("_", 1, @namespaces);

  my $dataGuards = "";
  { # parse Daten class file
    open(FILE, $filenameInput) || die ("unable to read file $filenameInput");
    my $line;
    print "Data class:\n";
    while (not eof(FILE))
    {
      $line = <FILE>;
      if ($line =~ /^$INDENT(\w+)\s+(\w+)\(\);\s+$/)
      {
        print "    $1 $2();\n";
        die "return value is not bool for method $2" if ($1 ne "bool");
        $dataGuards .= "${INDENT}virtual $1 $2() const = 0;\n";
      }
    }
    close FILE;
  }
  my $includes = "#include <tsd/common/stm/IDataPool.hpp>\n";
  $includes .= "#include <$actionsInclude.hpp>";
  my $description = "/// \@brief Datapool that is used for guards in the statemachine.";
  my $methods = <<END;
$INDENT/// \@brief Getter for the actions interface.
$INDENT/// \@return The instance.
${INDENT}virtual $actionsInterface& get$actionsInterface() = 0;

$INDENT// Guards and Getters for the Data class
$dataGuards
END

  generateInterface($fileName, $includeGuard, $includes, $namespaceOpen, $namespaceClose, $interfaceName, $methods, $description,
                    "${INDENT}: public tsd::common::stm::IDataPool\n");
}

sub generateActionHandler {
  my ($filenameInput, $namespace, $nameStm) = @_;

  my @namespaces = split('::', $namespace);

  my $interfaceName = $namespaces[$#namespaces];
  my $fileName = "$interfaceName.hpp";
  my $namespaceOpen = createOpeningNamespaceString(@namespaces);
  my $namespaceClose = createClosingNamespaceString(@namespaces);
  my $includeGuard = concatenateStrings("_", 1, @namespaces);
  my $lengthNameStm = length $nameStm;

  my @actions;
  my @stmEvents;
  my @stmStates;
  { # parse Stm.hpp class file
    my $enumDecl = "${INDENT}${INDENT}enum e";
    open(FILE, $filenameInput) || die ("unable to read file $filenameInput");
    my $line;
    my $eventDecl = 0;
    my $stateDecl = 0;
    print "Parse actions for file \'$filenameInput\':\n";
    while (not eof(FILE))
    {
      $line = <FILE>;
      if ($line =~ /^void action_(\w+)\(::tsd::common::stm::IDataPool/) { # ignore the rest of the line
        my $match = $1;
        unless ($match =~ /^CompoundAction/) {
          print "    action $match\n";
          push @actions, $match;
        }
      } elsif ($line =~ /class EventEnum/) {
        $eventDecl = 1;
      } elsif ($line =~ /class StatesEnum/) {
        $eventDecl = 0;
        $stateDecl = 1;
      } else {
        if ($eventDecl and $line =~ /(\w+) = \d+/) {
          push @stmEvents, $1;
        } elsif ($stateDecl and $line =~ /(\w+) = \d+/) {
          my $state;
          if (length($1) eq $lengthNameStm) {
            $state = "";
          } else {
            $state = substr $1, 1 + $lengthNameStm;
          }
          push @stmStates, $state;
        }
      }
    }
    close FILE;
  }

  my $includes = "#include <tsd/common/stm/IEventParameter.hpp>";
  my $description = "/// \@brief Actions that are uses in the statemachine.";
  my $methods = "$INDENT/// \@see handleError\n";
  $methods .= "${INDENT}virtual void handleError(tsd::common::stm::IEventParameter* param) = 0;\n\n";
  foreach my $a (@actions) {
    $methods .= "$INDENT/// \@see action_$a\n";
    $methods .= "${INDENT}virtual void action$a(tsd::common::stm::IEventParameter* param) = 0;\n\n";
  }

  generateInterface($fileName, $includeGuard, $includes, $namespaceOpen, $namespaceClose, $interfaceName, $methods, $description, "");

#   return @actions;
  my @results;
  push @results, \@actions;
  push @results, \@stmEvents;
  push @results, \@stmStates;
  return @results;
}

sub adaptDeclaration {
  my ($pathStm, $nameStm, $namespace, $nameIData) = @_;

  my @namespaces = split('::', $namespace);
  push @namespaces, $nameStm; # add Name of STM

  my $namespaceOpen = createOpeningNamespaceString(@namespaces);
  my $namespaceClose = createClosingNamespaceString(@namespaces);
  my $includeGuard = concatenateStrings("_", 1, @namespaces) . "_HPP";

  my $filename = "$nameStm.hpp";
  my $fnPath = $pathStm . "/" . $filename;

  my @content;
  { # parse Stm.hpp class file and adapt to @content
    my $incGuard = uc "${pathStm}_${nameStm}_HPP_";
    my $enumDecl = "${INDENT}${INDENT}};";
    my $datapoolGet = "${INDENT}virtual ::tsd::common::stm::IDataPool";
    open(FILE, $fnPath) || die ("unable to read file $fnPath");
    my $line;
    print "Adapt file $filename:\n";
    while (not eof(FILE))
    {
      $line = <FILE>;
      if ($line =~ /$incGuard/) { # ignore the rest of the line
        $line =~ s/$incGuard/$includeGuard/g;
        push @content, $line;
      } elsif ($line =~ /Daten \*/) {
        $line =~ s/Daten \*/$nameIData */g;
        push @content, $line;
      } elsif ($line =~ /^#include (<iostream>)|("\w+\.hpp")/) { # ignore complete
      } elsif ($line =~ /^namespace $pathStm \{/) { # found opening namespaces
        push @content, "#include <string>\n\n"; # needed for toString()
        push @content, $namespaceOpen;
        push @content, "\nclass $nameIData;\n"; # forward declaration of data pool
      } elsif ($line =~ /^\} \/\/ - End of namespace/) { # found closing namespaces
        push @content, $namespaceClose;
      } elsif ($line =~ /^$enumDecl/) {
        push @content, $line;
        push @content, "${INDENT}${INDENT}static const char* toString(const uint16_t value);\n";
      } elsif ($line =~ /^$datapoolGet/) {
        push @content, "${INDENT}virtual ::tsd::common::stm::IDataPool * getDataPool() const;\n";
      } else {
        push @content, $line;
      }
    }
  }

  my $fileContent = "";
  foreach my $c (@content) {
    $fileContent .= $c;
  }
  writeToFile($filename, $fileContent);
}

sub adaptImplementation {
  my ($pathStm, $nameStm, $namespace, $nameIData, $nameIAction, @results) = @_;

  my @actions = @{$results[0]};
  my @stmEvents = @{$results[1]};
  my @stmStates = @{$results[2]};

  my @namespaces = split('::', $namespace);
  my @nsIData;
  my @nsIAction;
  foreach my $n (@namespaces) {
    push @nsIData, $n;
    push @nsIAction, $n;
  }
  push @nsIData, $nameIData;
  push @nsIAction, $nameIAction;

  push @namespaces, $nameStm; # add Name of STM

  my $namespaceOpen = createOpeningNamespaceString(@namespaces);
  my $namespaceClose = createClosingNamespaceString(@namespaces);
  my $incnameIData = concatenateStrings("/", 0, @nsIData);
  my $incnameIActions = concatenateStrings("/", 0, @nsIAction);
  my $filename = "$nameStm.cpp";
  my $fnPath = $pathStm . "/" . $filename;

  my $actionImplementation = "void handleError(tsd::common::stm::IDataPool* d, tsd::common::stm::IEventParameter* param)\n";
  $actionImplementation .= "{\n${INDENT}callIActionHandler(d, param, &${nameIAction}::handleError);\n}\n\n";
  foreach my $a (@actions) {
    $actionImplementation .= "void action_$a(tsd::common::stm::IDataPool* d, tsd::common::stm::IEventParameter* param)\n";
    $actionImplementation .= "{\n${INDENT}callIActionHandler(d, param, &${nameIAction}::action$a);\n}\n\n";
  }

  my $actionImpl = <<END;
void callIActionHandler(tsd::common::stm::IDataPool *d, tsd::common::stm::IEventParameter *p, void (${nameIAction}::*action)(tsd::common::stm::IEventParameter*))
{
${INDENT}$nameIData* c = dynamic_cast< $nameIData * >(d);
${INDENT}if (c)
${INDENT}{
${INDENT}${INDENT}$nameIAction& a = c->get$nameIAction();
${INDENT}${INDENT}(a.*action)(p);
${INDENT}}
}

$actionImplementation
END

  my $eventToString = generateToString($nameStm, "EventEnum" ,@stmEvents);
  my $stateToString = generateToString($nameStm, "StatesEnum" ,@stmStates);

  my @content;
  { # parse Stm.hpp class file and adapt to @content
    my $replaceDaten = "::${pathStm}::Daten";
    my $flagCheckParameter = 0;
    open(FILE, $fnPath) || die ("unable to read file $fnPath");
    my $line;
    print "Adapt file $filename:\n";
    while (not eof(FILE))
    {
      $line = <FILE>;
      if ($line =~ /^#include "$nameStm.hpp"/) {
        push @content, $line;
        push @content, "#include <$incnameIData.hpp>\n";
        push @content, "#include <$incnameIActions.hpp>\n";
      } elsif ($line =~ /^namespace $pathStm \{/) { # found opening namespaces
        push @content, $namespaceOpen;
      } elsif ($line =~ /^\} \/\/ - End of namespace/) { # found closing namespaces
        push @content, $actionImpl;
        push @content, $namespaceClose;
      } elsif ($line =~ /$replaceDaten\s*\*/) { # first replace absolute path to Daten
        $line =~ s/$replaceDaten\s*\*/$nameIData*/g;
        $line =~ s/static_cast/dynamic_cast/g; # change cast because this might be a problem during runtime
        push @content, $line;
      } elsif ($line =~ /Daten\s*\*/) {
        $line =~ s/Daten\s*\*/$nameIData*/g;
        push @content, $line;
      } elsif ($line =~ /::$nameStm/) {
        $line =~ s/(::\w+)*::$nameStm/$nameStm/g;
        push @content, $line;
      } elsif ($line =~ /$nameStm\::\~$nameStm\(\)/) {
        push @content, $line;
        push @content, "\ntsd::common::stm::IDataPool* ${nameStm}::getDataPool() const { return mpDataPool; }\n";
      } elsif ($line =~ /$nameStm\::EventEnum::\~EventEnum/) {
        push @content, $line;
        push @content, $eventToString;
        push @content, $stateToString;
      } elsif ($line =~ /checkEventParameter/) {
        $flagCheckParameter = 1;
        $line =~ s/pAstractEventParameter//g;
        push @content, $line;
        push @content, "{ return true; }\n";
# There might be a problem with this line when calling stm initialize with a Parameter -> so always return true.
#         push @content, "{ return pAstractEventParameter == nullptr; }\n";
      } else {
        if ($flagCheckParameter eq 0) {
          push @content, $line;
        } elsif ($line =~ /\}/) {
          $flagCheckParameter = 0;
        }
      }
    }
  }

  my $fileContent = "";
  foreach my $c (@content) {
    $fileContent .= $c;
  }
  writeToFile($filename, $fileContent);
}

sub generateFacadeDeclaration {
  my ($nameStm, $namespace, $nameIData, $stmEventsArray) = @_;

  my @namespaces = split('::', $namespace);
  my @stmEvents = @{$stmEventsArray};

  my $facadeName = $namespaces[$#namespaces];
  my $fileName = "$facadeName.hpp";
  my $namespaceOpen = createOpeningNamespaceString(@namespaces);
  my $namespaceClose = createClosingNamespaceString(@namespaces);
  my $includeGuard = concatenateStrings("_", 1, @namespaces);

  my $methods = "${INDENT}/// \@brief Initialize the statemachine. Have to be called in order to do any transitions.\n";
  $methods .= "${INDENT}/// \@param[in] parameter Optional parameter which is given to the first action that on a transitions.\n";
  $methods .= "${INDENT}virtual void initialize(tsd::common::stm::IEventParameter* parameter = nullptr);\n\n";
  foreach my $e (@stmEvents) {
    $methods .= "${INDENT}/// \@brief Fires event $e into the statemachine.\n";
    $methods .= "${INDENT}/// \@param[in] parameter Optional parameter which is given to the first action that on a transitions.\n";
    $methods .= "${INDENT}virtual void fire$e(tsd::common::stm::IEventParameter* parameter = nullptr);\n\n";
  }

  my $fileContent = <<END;
//////////////////////////////////////////////////////////////////////
/// \@file $fileName
///
/// \@author $AUTHORMAIL
///
/// Generated by $SCRIPTNAME version $VERSION
/// Copyright (c) Preh Car Connect GmbH
/// CONFIDENTIAL
//////////////////////////////////////////////////////////////////////

#ifndef $includeGuard\_HPP
#define $includeGuard\_HPP

#include <memory>

namespace tsd { namespace common { 
${INDENT}namespace logging { class Logger; }
${INDENT}namespace stm { class IEventParameter; }
}}

$namespaceOpen
class IData;
class $nameStm;

/// \@brief Facade for the $nameStm.
class $facadeName
{
protected:
$INDENT$facadeName($nameIData* data, tsd::common::logging::Logger* log);
public:
${INDENT}virtual ~$facadeName() = default; ///< Default destructor
$INDENT$facadeName(const $facadeName&) = delete; ///< Forbidden copy constructor
$INDENT$facadeName& operator=(const $facadeName&) = delete; ///< Forbidden assignment operator

${INDENT}/// \@brief Creates a new facade for the $nameStm.
${INDENT}/// \@param[in] data Datapool with guards and action handler.
${INDENT}/// \@param[in] log Logger that is used for debugging purpose.
${INDENT}static std::shared_ptr<$facadeName> create($nameIData* data = nullptr, tsd::common::logging::Logger* log = nullptr);

public:
$methods
${INDENT}std::shared_ptr<${nameStm}>& getStm();

private:
${INDENT}void handleEvent(const uint16_t event, tsd::common::stm::IEventParameter* parameter);
${INDENT}std::shared_ptr<$nameStm> m_Stm;
${INDENT}tsd::common::logging::Logger* m_Log;

};

$namespaceClose
#endif // $includeGuard\_HPP
END

  writeToFile($fileName, $fileContent);
}

sub generateFacadeImplementation {
  my ($nameStm, $namespace, $nameFacade, $nameIData, $stmEventsArray) = @_;
  my @stmEvents = @{$stmEventsArray};

  my @namespaces = split('::', $namespace);
  my @nsIData;
  my @nsStm;
  foreach my $n (@namespaces) {
    push @nsIData, $n;
    push @nsStm, $n;
  }
  push @nsIData, $nameIData;
  push @nsStm, $nameStm;

  push @namespaces, $nameFacade; # add Name of STM

  my $fileName = "$nameFacade.cpp";
  my $namespaceOpen = createOpeningNamespaceString(@namespaces);
  my $namespaceClose = createClosingNamespaceString(@namespaces);

  my $incnameIData = concatenateStrings("/", 0, @nsIData);
  my $incnameStm = concatenateStrings("/", 0, @nsStm);

  my $methods = "";
  foreach my $e (@stmEvents) {
    $methods .= "void\n";
    $methods .= "${nameFacade}::fire$e(tsd::common::stm::IEventParameter* parameter)\n";
    $methods .= "{\n${INDENT}handleEvent(${nameStm}::EventEnum::$e, parameter);\n}\n\n";
  }

  my $fileContent = <<END;
//////////////////////////////////////////////////////////////////////
/// \@file $fileName
///
/// \@author $AUTHORMAIL
///
/// Generated by $SCRIPTNAME version $VERSION
/// Copyright (c) Preh Car Connect GmbH
/// CONFIDENTIAL
//////////////////////////////////////////////////////////////////////

#include "$nameFacade.hpp"

#include <tsd/common/logging/Logger.hpp>
#include <tsd/common/stm/IEventParameter.hpp>

#include <$incnameIData.hpp>
#include <$incnameStm.hpp>

$namespaceOpen

using tsd::common::logging::LogLevel;

${nameFacade}::${nameFacade}($nameIData* data, tsd::common::logging::Logger* log) :
${INDENT}m_Stm(std::make_shared<$nameStm>(data)),
${INDENT}m_Log(log)
{}

std::shared_ptr<${nameFacade}>
${nameFacade}::create($nameIData* data, tsd::common::logging::Logger* log)
{
${INDENT}return std::shared_ptr<${nameFacade}>(new ${nameFacade}(data,log));
}

void
${nameFacade}::initialize(tsd::common::stm::IEventParameter* parameter)
{
${INDENT}m_Stm->initialize(parameter);
}

$methods
void
${nameFacade}::handleEvent(const uint16_t event, tsd::common::stm::IEventParameter* parameter)
{
${INDENT}if (m_Log)
${INDENT}{
${INDENT}${INDENT}LOG_MSG(*m_Log, LogLevel::Debug, "${nameStm}[" << ${nameStm}::StatesEnum::toString(m_Stm->getCurrentState()) <<
${INDENT}${INDENT}        "] event=" << ${nameStm}::EventEnum::toString(event) << std::endl);
${INDENT}}
${INDENT}m_Stm->fireEvent(event, parameter);
${INDENT}if (m_Log)
${INDENT}{
${INDENT}${INDENT}LOG_MSG(*m_Log, LogLevel::Debug, "${nameStm}[" << ${nameStm}::StatesEnum::toString(m_Stm->getCurrentState()) <<
${INDENT}${INDENT}        "]" << std::endl);
${INDENT}}
}

std::shared_ptr<${nameStm}>& ${nameFacade}::getStm()
{
${INDENT}return(m_Stm);
}


$namespaceClose
END

  writeToFile($fileName, $fileContent);
}

###############################################
# main
###############################################

if ($#ARGV ne 2) {
  print $HELPMESSAGE;
  exit(1);
}

my $ns = $ARGV[0]; # "tsd::bli::bla::stm";
my $pathStm= $ARGV[1]; # "stm";
my $nameStm= $ARGV[2]; # "StatusStm";

my $nameIAction = "IActionHandler";
my $nameIData = "IData";
my $nameFacade = "${nameStm}Facade";

my $nsIData = "${ns}::$nameIData";
my $nsIAction = "${ns}::$nameIAction";
my $nsFacade = "${ns}::$nameFacade";

generateVirtualDatapool("$pathStm/Daten.hpp", $nsIData, $nameIAction);

my @results = generateActionHandler("$pathStm/$nameStm.hpp", $nsIAction, $nameStm);

adaptDeclaration($pathStm, $nameStm, $ns, $nameIData);
adaptImplementation($pathStm, $nameStm, $ns, $nameIData, $nameIAction, @results);
generateFacadeDeclaration($nameStm, $nsFacade, $nameIData, $results[1]);
generateFacadeImplementation($nameStm, $ns, $nameFacade, $nameIData, $results[1]);

exit(0);
